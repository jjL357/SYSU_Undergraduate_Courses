### 习题1

CUDA中的`__syncthreads()`函数确保同一个线程块内的线程协调它们的活动，起到一个屏障同步的作用。具体而言，当一个线程块中的所有线程执行到`__syncthreads()`时，它们都会在此处等待，直到该线程块中的所有其他线程也到达这一点。只有当线程块内的所有线程都到达屏障点时，它们才会继续执行后续的代码。这确保了在`__syncthreads()`之前的所有操作在整个线程块中都完成之后，才开始执行`__syncthreads()`之后的操作。其作用在于保证数据的一致性和同步性，尤其是在需要多个线程协作处理数据的情境下非常重要。

### 习题2

#### (1)
当同一个warp中的线程遵循不同的执行路径时，我们称这些线程表现出“分支发散”（branch divergence）现象。分支发散发生在warp中的不同线程在执行条件语句（如if-else）时，选择了不同的执行路径。这种现象会导致warp内的线程不能同时执行，必须分别执行不同路径的指令，从而降低并行效率和性能。

#### (2)
在实现一个向量加法核函数（addVecKernel）时，当向量长度不是线程块大小的整数倍时，会出现分支发散现象。假设向量长度为1003，线程块大小为64，一个warp有32个线程。

出现分支发散现象的原因在于，向量长度1003除以线程块大小64，得到16个完整的线程块和1个部分线程块（包含11个线程）。在执行最后一个线程块时，仅有11个线程参与计算，而剩余的线程将空闲等待，这导致warp内的线程不能同时执行，出现分支发散。

对于不同向量长度对性能的影响分析：
- 向量长度为100：由于100小于线程块大小的整数倍（64），只有两个warp需要处理100个元素，发散的影响较小。
- 向量长度为10000：虽然10000除以64等于156个完整线程块和1个部分线程块（包含16个线程），大多数情况下不会有发散，只有最后的1个部分线程块会发散。因此，发散对性能的影响相对较小。

### 习题3

CUDA中的存储层次结构主要包括以下几种类型的内存：

1. **全局内存（Global Memory）**
   - 作用域：所有线程
   - 生存周期：程序运行期间
   - 硬件所在位置：片外

2. **共享内存（Shared Memory）**
   - 作用域：线程块内的所有线程
   - 生存周期：线程块的生命周期
   - 硬件所在位置：片上

3. **常量内存（Constant Memory）**
   - 作用域：所有线程
   - 生存周期：程序运行期间
   - 硬件所在位置：片外（但有片上缓存）

4. **纹理内存（Texture Memory）**
   - 作用域：所有线程
   - 生存周期：程序运行期间
   - 硬件所在位置：片外（但有片上缓存）

5. **本地内存（Local Memory）**
   - 作用域：单个线程
   - 生存周期：线程的生命周期
   - 硬件所在位置：片外

6. **寄存器（Registers）**
   - 作用域：单个线程
   - 生存周期：线程的生命周期
   - 硬件所在位置：片上

### 习题4

CUDA全局内存上的统一内存寻址技术（Unified Memory）允许CPU和GPU共享一块内存地址空间，简化了内存管理。

**优点**：
- 简化编程：开发者不需要手动管理CPU和GPU之间的数据传输，减少了编写复杂内存拷贝代码的需求。
- 减少错误：减少了因内存拷贝错误导致的bug，提供更直观的编程模型。

**缺点**：
- 性能损失：自动数据传输机制可能导致性能损失，特别是在大量数据传输或频繁访问内存时。
- 更高的延迟：统一内存可能引入更高的访问延迟，特别是在CPU和GPU频繁切换访问时。

### 习题5

在CUDA编程中，共享内存的存储体冲突（bank conflict）是指多个线程同时访问共享内存中的不同地址，但这些地址映射到相同的内存存储体（bank）。这会导致访问顺序执行，从而降低并行性能。

**产生原因**：
共享内存被分成多个存储体（通常是32个或64个），每个存储体可以同时服务一个线程的请求。如果多个线程同时访问不同地址但这些地址位于同一个存储体，就会发生存储体冲突。

### 习题6

判断kernel是否可以达到满占用（full occupancy），需要考虑以下因素：线程数、线程块数、寄存器数和共享内存等。

**a. kernel的每个block有128个线程，每个线程有30个寄存器。**
- 每个线程块的寄存器需求：128 * 30 = 3840
- 每个SM的寄存器限制：65536
- 最大线程块数：65536 / 3840 ≈ 17
- 硬件限制：每个SM最多32个线程块

因为寄存器数量限制，最多可以有17个线程块，无法达到满占用。

**b. kernel的每个block有32个线程，每个线程有29个寄存器。**
- 每个线程块的寄存器需求：32 * 29 = 928
- 每个SM的寄存器限制：65536
- 最大线程块数：65536 / 928 ≈ 70
- 硬件限制：每个SM最多32个线程块

由于线程块数量限制，最多可以有32个线程块，可以达到满占用。

**c. kernel的每个block有256个线程，每个线程有34个寄存器。**
- 每个线程块的寄存器需求：256 * 34 = 8704
- 每个SM的寄存器限制：65536
- 最大线程块数：65536 / 8704 ≈ 7
- 硬件限制：每个SM最多32个线程块

因为寄存器数量限制，最多可以有7个线程块，无法达到满占用。